Regular Programs
1.	List Comprehensions
if __name__ == '__main__':
    x = int(input())
    y = int(input())
    z = int(input())
    n = int(input())

    output=[]
    for i in range(x+1):
        for j in range(y+1):
            for k in range(z+1):
                if i+j+k==n:
                    continue
                else:
                    output.append([i,j,k])
    print(output)

2.	Nested Lists
if __name__ == '__main__':
    lis=[]
    for _ in range(int(input())):
        name = input()
        score = float(input())
        lis.append([name,score])
    lis.sort(key=lambda lis:lis[1])
    second_lowest=[]
    for i in range(len(lis)):
        if lis[i][1]!=lis[0][1]:
            second_lowest.append(lis[i][0])
            for j in range(i+1,len(lis)):
                if lis[j][1]==lis[i][1]:
                    second_lowest.append(lis[j][0])
                else:
                    break
            break        
        else:
            continue
    second_lowest.sort()
    for i in second_lowest:
        print(i)
3.	sWAP cASE
def swap_case(s):
    case_change=[]
    for i in range(len(s)):
        if (s[i].isupper())==True:
            case_change.append(s[i].lower())
        elif (s[i].islower()==True):
            case_change.append(s[i].upper())
        else:
            case_change.append(s[i])    
        stri=''
    return stri.join(case_change)

4.	Find a string
def count_substring(string, sub_string):
    count=0
    for i in range(len(string)):
        for j in range(len(sub_string)):
            if string[i+j]==sub_string[j] and j==(len(sub_string)-1):
                count=count+1  
            if string[i+j]!=sub_string[j]:
                break  
        if i==len(string)-len(sub_string):
            break            
    return count
if __name__ == '__main__':
    string = input().strip()
    sub_string = input().strip()
    count = count_substring(string, sub_string)
    print(count)

5.	Designer Door Mat
n,m=input().split()
c='|'
v='.'
n=int(n)
m=int(m)
j=n//2-1
for i in range(n):
    if i==n//2:
        print('WELCOME'.center(m,'-'))
    else:
        if i<n/2:    
            print(((v+c+v)*(2*i+1)).center(m,'-'))
        else:
            print(((v+c+v)*(2*j+1)).center(m,'-'))
            j=j-1

6.	Alphabet Rangoli
def print_rangoli(n):
    alpha = [chr(i) for i in range(97, 123)]
    for i in range(n - 1, -n, -1):
        row = '-'.join(alpha[n - 1:abs(i):-1] + alpha[abs(i):n])
        print(row.center(4 * n - 3, '-'))

if __name__ == '__main__':
    n = int(input())
    print_rangoli(n)


Additional Programs
1.	Word Order
from collections import OrderedDict
d=OrderedDict()
n=int(input())
for i in range(n):
    s=input()
    if s in d.keys():
        d[s]+=1
    else:
        d[s]=1
print(len(d.keys()))
print(' '.join([str(d[k]) for k in d.keys()]))
2.	The Minion Game
def minion_game(string):
    k = 0  # Kevin's score (vowels)
    s = 0  # Stuart's score (consonants)
    vowels = "AEIOU"   # can use uppercase only if we uppercase the input

    for i in range(len(string)):
        if string[i] in vowels:
            k += len(string) - i
        else:
            s += len(string) - i

    if k > s:
        print("Kevin", k)
    elif k == s:
        print("Draw")
    else:
        print("Stuart", s)

if __name__ == '__main__':
    s = input().strip().upper()
    minion_game(s)




3.	Compress the string
S=input()
i=1
a=[]
count=1
while i<len(S):
    if S[i]==S[i-1]:
        count+=1
        i+=1
    else:
        a.append((count,int(S[i-1])))
        i+=1
        count=1
a.append((count,int(S[i-1])))
for i in a:
    print(i,end=' ')

4.	Text wrap
import textwrap
def wrap(string, max_width):
    return textwrap.TextWrapper(width=max_width).fill(text=string)
if __name__ == '__main__':
    string, max_width = input(), int(input())
    result = wrap(string, max_width)
    print(result)
